<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IT-ERA Chatbot - Browser Integration Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .test-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.warning { background: #fff3cd; color: #856404; }
        .status.info { background: #d1ecf1; color: #0c5460; }
        
        .test-results {
            font-family: monospace;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover { background: #106ebe; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        
        .config-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 5px 0;
        }
        
        label {
            font-weight: bold;
            display: block;
            margin-top: 10px;
        }
        
        .widget-preview {
            position: relative;
            height: 200px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0078d4;
            margin-bottom: 5px;
        }
        
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <h1>üß™ IT-ERA Chatbot - Browser Integration Test</h1>
    <p>Test the chatbot widget directly in the browser with real-time results.</p>

    <!-- Configuration Section -->
    <div class="test-container">
        <h2>‚öôÔ∏è Configuration</h2>
        <div class="config-section">
            <div>
                <label for="apiEndpoint">API Endpoint:</label>
                <input type="url" id="apiEndpoint" value="https://it-era-chatbot.bulltech.workers.dev/api/chat" placeholder="https://...">
                
                <label for="position">Widget Position:</label>
                <select id="position">
                    <option value="bottom-right">Bottom Right</option>
                    <option value="bottom-left">Bottom Left</option>
                </select>
                
                <label for="autoOpen">Auto Open:</label>
                <select id="autoOpen">
                    <option value="false">No</option>
                    <option value="true">Yes</option>
                </select>
            </div>
            <div>
                <label for="primaryColor">Primary Color:</label>
                <input type="color" id="primaryColor" value="#667eea">
                
                <label for="secondaryColor">Secondary Color:</label>
                <input type="color" id="secondaryColor" value="#764ba2">
                
                <label for="companyName">Company Name:</label>
                <input type="text" id="companyName" value="IT-ERA" placeholder="Company name">
            </div>
        </div>
    </div>

    <!-- Widget Preview -->
    <div class="test-container">
        <h2>üëÄ Widget Preview</h2>
        <div class="widget-preview" id="widgetPreview">
            <div>Widget will appear here</div>
        </div>
    </div>

    <!-- Test Controls -->
    <div class="test-container">
        <h2>üéÆ Test Controls</h2>
        <button onclick="loadWidget()">üîÑ Load Widget</button>
        <button onclick="testHealthCheck()">üè• Health Check</button>
        <button onclick="runBasicTests()">üß™ Run Basic Tests</button>
        <button onclick="runPerformanceTests()">‚ö° Performance Tests</button>
        <button onclick="runStressTest()">üí™ Stress Test</button>
        <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
    </div>

    <!-- Metrics -->
    <div class="test-container">
        <h2>üìä Real-time Metrics</h2>
        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value" id="healthStatus">Unknown</div>
                <div class="metric-label">Health Status</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="responseTime">0ms</div>
                <div class="metric-label">Last Response Time</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="testsPassed">0</div>
                <div class="metric-label">Tests Passed</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="testsFailed">0</div>
                <div class="metric-label">Tests Failed</div>
            </div>
        </div>
    </div>

    <!-- Test Results -->
    <div class="test-container">
        <h2>üìã Test Results</h2>
        <div id="testResults" class="test-results">Ready to run tests...</div>
    </div>

    <!-- Status Messages -->
    <div id="statusContainer"></div>

    <script>
        // Global state
        let testResults = [];
        let currentSessionId = null;
        let widgetInstance = null;
        let testMetrics = {
            testsPassed: 0,
            testsFailed: 0,
            healthStatus: 'Unknown',
            lastResponseTime: 0
        };

        // Utility functions
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.textContent += logEntry + '\n';
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
            
            console.log(logEntry);
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('statusContainer');
            const statusElement = document.createElement('div');
            statusElement.className = `status ${type}`;
            statusElement.textContent = message;
            statusDiv.appendChild(statusElement);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (statusElement.parentNode) {
                    statusElement.parentNode.removeChild(statusElement);
                }
            }, 5000);
        }

        function updateMetrics() {
            document.getElementById('healthStatus').textContent = testMetrics.healthStatus;
            document.getElementById('responseTime').textContent = testMetrics.lastResponseTime + 'ms';
            document.getElementById('testsPassed').textContent = testMetrics.testsPassed;
            document.getElementById('testsFailed').textContent = testMetrics.testsFailed;
        }

        function getConfig() {
            return {
                apiEndpoint: document.getElementById('apiEndpoint').value,
                position: document.getElementById('position').value,
                primaryColor: document.getElementById('primaryColor').value,
                secondaryColor: document.getElementById('secondaryColor').value,
                autoOpen: document.getElementById('autoOpen').value === 'true',
                companyName: document.getElementById('companyName').value
            };
        }

        // Widget loading
        async function loadWidget() {
            try {
                log('Loading chatbot widget...', 'info');
                
                // Remove existing widget
                const existingWidget = document.getElementById('itera-chat-widget');
                if (existingWidget) {
                    existingWidget.remove();
                }
                
                // Remove existing styles
                const existingStyles = document.getElementById('itera-chat-styles');
                if (existingStyles) {
                    existingStyles.remove();
                }
                
                // Load widget script dynamically
                const config = getConfig();
                window.iteraChatConfig = config;
                
                const script = document.createElement('script');
                script.src = '../api/src/chatbot/widget/chat-widget.js';
                script.onload = () => {
                    log('‚úÖ Widget loaded successfully', 'success');
                    showStatus('Widget loaded successfully', 'success');
                };
                script.onerror = () => {
                    log('‚ùå Failed to load widget script', 'error');
                    showStatus('Failed to load widget script', 'error');
                };
                
                document.head.appendChild(script);
                
            } catch (error) {
                log(`‚ùå Widget loading error: ${error.message}`, 'error');
                showStatus('Widget loading failed', 'error');
            }
        }

        // Health check
        async function testHealthCheck() {
            try {
                log('Running health check...', 'info');
                const startTime = Date.now();
                
                const response = await fetch(getConfig().apiEndpoint.replace('/api/chat', '/health'));
                const responseTime = Date.now() - startTime;
                testMetrics.lastResponseTime = responseTime;
                
                if (!response.ok) {
                    throw new Error(`Health check failed: ${response.status}`);
                }
                
                const health = await response.json();
                testMetrics.healthStatus = health.status;
                
                log(`‚úÖ Health check passed (${responseTime}ms)`, 'success');
                log(`   Status: ${health.status}`, 'info');
                log(`   Service: ${health.service}`, 'info');
                log(`   AI Enabled: ${health.ai?.enabled || false}`, 'info');
                log(`   Features: ${Object.keys(health.features || {}).join(', ')}`, 'info');
                
                testMetrics.testsPassed++;
                showStatus('Health check passed', 'success');
                
            } catch (error) {
                log(`‚ùå Health check failed: ${error.message}`, 'error');
                testMetrics.healthStatus = 'Error';
                testMetrics.testsFailed++;
                showStatus('Health check failed', 'error');
            }
            
            updateMetrics();
        }

        // Basic functionality tests
        async function runBasicTests() {
            log('üß™ Starting basic functionality tests...', 'info');
            
            const tests = [
                { name: 'Widget Initialization', test: testWidgetInit },
                { name: 'Message Flow', test: testMessageFlow },
                { name: 'Session Management', test: testSessionPersistence },
                { name: 'Intent Recognition', test: testIntentRecognition },
                { name: 'Error Handling', test: testErrorHandling }
            ];
            
            for (const testCase of tests) {
                try {
                    log(`Running ${testCase.name}...`, 'info');
                    await testCase.test();
                    log(`‚úÖ ${testCase.name} passed`, 'success');
                    testMetrics.testsPassed++;
                } catch (error) {
                    log(`‚ùå ${testCase.name} failed: ${error.message}`, 'error');
                    testMetrics.testsFailed++;
                }
            }
            
            updateMetrics();
            showStatus('Basic tests completed', 'info');
        }

        // Individual test functions
        async function testWidgetInit() {
            const startTime = Date.now();
            const response = await fetch(getConfig().apiEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'start' })
            });
            
            testMetrics.lastResponseTime = Date.now() - startTime;
            
            if (!response.ok) {
                throw new Error(`Init failed: ${response.status}`);
            }
            
            const result = await response.json();
            if (!result.success || !result.sessionId) {
                throw new Error('Invalid initialization response');
            }
            
            currentSessionId = result.sessionId;
            log(`   Session ID: ${currentSessionId}`, 'info');
        }

        async function testMessageFlow() {
            if (!currentSessionId) {
                await testWidgetInit();
            }
            
            const testMessage = "Ciao, ho bisogno di informazioni";
            const startTime = Date.now();
            
            const response = await fetch(getConfig().apiEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'message',
                    message: testMessage,
                    sessionId: currentSessionId
                })
            });
            
            testMetrics.lastResponseTime = Date.now() - startTime;
            
            if (!response.ok) {
                throw new Error(`Message failed: ${response.status}`);
            }
            
            const result = await response.json();
            if (!result.success || !result.response) {
                throw new Error('Invalid message response');
            }
            
            log(`   Response length: ${result.response.length}`, 'info');
            log(`   Intent: ${result.intent || 'N/A'}`, 'info');
        }

        async function testSessionPersistence() {
            if (!currentSessionId) {
                await testWidgetInit();
            }
            
            // Send two messages with same session
            for (let i = 1; i <= 2; i++) {
                const response = await fetch(getConfig().apiEndpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'message',
                        message: `Test message ${i}`,
                        sessionId: currentSessionId
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Session test ${i} failed: ${response.status}`);
                }
                
                const result = await response.json();
                if (result.sessionId !== currentSessionId) {
                    throw new Error('Session ID changed unexpectedly');
                }
            }
        }

        async function testIntentRecognition() {
            const intentTests = [
                { message: 'Ho bisogno di un preventivo', expectedKeywords: ['preventivo', 'gratuito'] },
                { message: 'EMERGENZA: server down', expectedKeywords: ['emergenza', 'urgente', '039'] },
                { message: 'Sicurezza informatica', expectedKeywords: ['sicurezza', 'firewall'] }
            ];
            
            for (const test of intentTests) {
                const response = await fetch(getConfig().apiEndpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'message',
                        message: test.message,
                        sessionId: currentSessionId
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Intent test failed: ${response.status}`);
                }
                
                const result = await response.json();
                
                // Check if response contains expected keywords
                const foundKeywords = test.expectedKeywords.filter(keyword => 
                    result.response.toLowerCase().includes(keyword.toLowerCase())
                );
                
                log(`   "${test.message}" ‚Üí Found ${foundKeywords.length}/${test.expectedKeywords.length} keywords`, 'info');
                
                if (foundKeywords.length === 0) {
                    throw new Error(`No expected keywords found in response for: ${test.message}`);
                }
            }
        }

        async function testErrorHandling() {
            // Test invalid JSON
            try {
                const response = await fetch(getConfig().apiEndpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: 'invalid json'
                });
                
                // Should either return error status or handle gracefully
                if (response.ok) {
                    const result = await response.json();
                    if (result.success === true) {
                        throw new Error('Error handling failed - invalid JSON should not succeed');
                    }
                }
                
                log('   Invalid JSON handled correctly', 'info');
            } catch (error) {
                if (!error.message.includes('should not succeed')) {
                    log('   Invalid JSON resulted in expected network error', 'info');
                }
            }
        }

        // Performance tests
        async function runPerformanceTests() {
            log('‚ö° Starting performance tests...', 'info');
            
            try {
                // Response time test
                const responseTimes = [];
                for (let i = 0; i < 5; i++) {
                    const startTime = Date.now();
                    
                    const response = await fetch(getConfig().apiEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'message',
                            message: `Performance test ${i}`,
                            sessionId: currentSessionId
                        })
                    });
                    
                    const responseTime = Date.now() - startTime;
                    responseTimes.push(responseTime);
                    
                    if (!response.ok) {
                        throw new Error(`Performance test ${i} failed: ${response.status}`);
                    }
                    
                    // Small delay between requests
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const avgResponseTime = Math.round(responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length);
                const maxResponseTime = Math.max(...responseTimes);
                const minResponseTime = Math.min(...responseTimes);
                
                log(`‚úÖ Performance test passed`, 'success');
                log(`   Average response time: ${avgResponseTime}ms`, 'info');
                log(`   Min/Max response time: ${minResponseTime}ms / ${maxResponseTime}ms`, 'info');
                
                testMetrics.lastResponseTime = avgResponseTime;
                testMetrics.testsPassed++;
                
                if (avgResponseTime > 5000) {
                    log(`‚ö†Ô∏è  Warning: Average response time is high (${avgResponseTime}ms)`, 'warning');
                    showStatus('Performance warning: High response times', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Performance test failed: ${error.message}`, 'error');
                testMetrics.testsFailed++;
            }
            
            updateMetrics();
        }

        // Stress test
        async function runStressTest() {
            log('üí™ Starting stress test...', 'info');
            
            try {
                // Send multiple concurrent requests
                const concurrentRequests = 5;
                const requests = [];
                
                for (let i = 0; i < concurrentRequests; i++) {
                    requests.push(fetch(getConfig().apiEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'message',
                            message: `Stress test concurrent request ${i}`,
                            sessionId: currentSessionId
                        })
                    }));
                }
                
                const startTime = Date.now();
                const responses = await Promise.all(requests);
                const totalTime = Date.now() - startTime;
                
                // Check all responses
                let successCount = 0;
                for (let i = 0; i < responses.length; i++) {
                    if (responses[i].ok) {
                        const result = await responses[i].json();
                        if (result.success) {
                            successCount++;
                        }
                    }
                }
                
                log(`‚úÖ Stress test completed`, 'success');
                log(`   Successful requests: ${successCount}/${concurrentRequests}`, 'info');
                log(`   Total time: ${totalTime}ms`, 'info');
                log(`   Average per request: ${Math.round(totalTime / concurrentRequests)}ms`, 'info');
                
                testMetrics.testsPassed++;
                
                if (successCount < concurrentRequests) {
                    log(`‚ö†Ô∏è  Warning: ${concurrentRequests - successCount} requests failed under stress`, 'warning');
                    showStatus('Stress test warning: Some requests failed', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Stress test failed: ${error.message}`, 'error');
                testMetrics.testsFailed++;
            }
            
            updateMetrics();
        }

        // Clear results
        function clearResults() {
            document.getElementById('testResults').textContent = 'Results cleared...\n';
            document.getElementById('statusContainer').innerHTML = '';
            testMetrics = { testsPassed: 0, testsFailed: 0, healthStatus: 'Unknown', lastResponseTime: 0 };
            updateMetrics();
            log('Test results cleared', 'info');
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            log('Browser integration test page loaded', 'info');
            updateMetrics();
            
            // Run initial health check
            setTimeout(testHealthCheck, 1000);
        });
    </script>
</body>
</html>